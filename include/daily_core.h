/* Copyright (c) 2022-2025, Daily */

#pragma once

/* Warning, this file is autogenerated, DO NOT MODIFY */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

#define STATS_CAPTURE_INTERVAL_SECS 2

#define REPORT_STATS_INTERVAL_MILLISECONDS 14900

#define NETWORK_STATS_UPDATING_INTERVAL_SECS 2

#define SEVERE_PACKET_LOSS_THRESHOLD 0.35

#define MODERATE_PACKET_LOSS_THRESHOLD 0.20

#if !defined(WASM32)
#define MINIMUM_WORKER_THREAD_COUNT 2
#endif

#if !defined(WASM32)
typedef enum DailyCallState {
#if !defined(WASM32)
  DailyCallState_Initialized,
#endif
#if !defined(WASM32)
  DailyCallState_Joining,
#endif
#if !defined(WASM32)
  DailyCallState_Joined,
#endif
#if !defined(WASM32)
  DailyCallState_Leaving,
#endif
#if !defined(WASM32)
  DailyCallState_Left,
#endif
} DailyCallState;
#endif

#if !defined(WASM32)
typedef enum DailyLogLevel {
#if !defined(WASM32)
  /**
   * A level lower than all log levels.
   */
  DailyLogLevel_Off,
#endif
#if !defined(WASM32)
  /**
   * Corresponds to the `Error` log level.
   */
  DailyLogLevel_Error,
#endif
#if !defined(WASM32)
  /**
   * Corresponds to the `Warn` log level.
   */
  DailyLogLevel_Warn,
#endif
#if !defined(WASM32)
  /**
   * Corresponds to the `Info` log level.
   */
  DailyLogLevel_Info,
#endif
#if !defined(WASM32)
  /**
   * Corresponds to the `Debug` log level.
   */
  DailyLogLevel_Debug,
#endif
#if !defined(WASM32)
  /**
   * Corresponds to the `Trace` log level.
   */
  DailyLogLevel_Trace,
#endif
} DailyLogLevel;
#endif

/**
 * A Daily call client. This is the main point of interaction of customers
 * with the Daily client API.
 * It maintains internal call state and connects together the different pieces
 * of state required for a call.
 */
typedef struct DailyRawCallClient DailyRawCallClient;

typedef struct Result_bool__JsValue Result_bool__JsValue;

#if !defined(WASM32)
typedef struct DailyCallClientAppMessageFns {
  void (*send_app_message)(struct DailyRawCallClient *client,
                           uint64_t request_id,
                           const char *message,
                           const char *participant);
} DailyCallClientAppMessageFns;
#endif

#if !defined(WASM32)
typedef struct DailyCallClientAudioLevelFns {
  void (*start_remote_participants_audio_level_observer)(struct DailyRawCallClient *client,
                                                         uint64_t request_id,
                                                         uint64_t interval);
  void (*stop_remote_participants_audio_level_observer)(struct DailyRawCallClient *client,
                                                        uint64_t request_id);
  void (*start_local_audio_level_observer)(struct DailyRawCallClient *client,
                                           uint64_t request_id,
                                           uint64_t interval);
  void (*stop_local_audio_level_observer)(struct DailyRawCallClient *client, uint64_t request_id);
} DailyCallClientAudioLevelFns;
#endif

#if !defined(WASM32)
typedef struct DailyCallClientCallStateFns {
  enum DailyCallState (*call_state)(struct DailyRawCallClient *client);
  void (*call_config_for)(struct DailyRawCallClient *client,
                          uint64_t request_id,
                          const char *url,
                          const char *token);
} DailyCallClientCallStateFns;
#endif

#if !defined(WASM32)
typedef struct DailyCallClientConnectionFns {
  void (*join)(struct DailyRawCallClient *client,
               uint64_t request_id,
               const char *url,
               const char *token,
               const char *client_settings);
  void (*leave)(struct DailyRawCallClient *client, uint64_t request_id);
  void (*set_proxy_url)(struct DailyRawCallClient *client,
                        uint64_t request_id,
                        const char *proxy_url);
  void (*set_ice_config)(struct DailyRawCallClient *client,
                         uint64_t request_id,
                         const char *ice_config);
} DailyCallClientConnectionFns;
#endif

#if !defined(WASM32)
typedef struct DailyCallClientDevicesFns {
  const char *(*available_devices)(struct DailyRawCallClient *client, const char *config);
  void (*trigger_devices_changed)(struct DailyRawCallClient *client);
} DailyCallClientDevicesFns;
#endif

#if !defined(WASM32)
typedef struct DailyCallClientInputsFns {
  const char *(*inputs)(struct DailyRawCallClient *client);
  void (*update_inputs)(struct DailyRawCallClient *client,
                        uint64_t request_id,
                        const char *input_settings);
  void (*add_custom_video_track)(struct DailyRawCallClient *client,
                                 uint64_t request_id,
                                 const char *name,
                                 const void *track_ptr);
  void (*update_custom_video_track)(struct DailyRawCallClient *client,
                                    uint64_t request_id,
                                    const char *name,
                                    const void *track_ptr);
  void (*remove_custom_video_track)(struct DailyRawCallClient *client,
                                    uint64_t request_id,
                                    const char *name);
  void (*add_custom_audio_track)(struct DailyRawCallClient *client,
                                 uint64_t request_id,
                                 const char *name,
                                 const void *track_ptr);
  void (*update_custom_audio_track)(struct DailyRawCallClient *client,
                                    uint64_t request_id,
                                    const char *name,
                                    const void *track_ptr);
  void (*remove_custom_audio_track)(struct DailyRawCallClient *client,
                                    uint64_t request_id,
                                    const char *name);
} DailyCallClientInputsFns;
#endif

#if !defined(WASM32)
typedef void DailyRawCallClientDelegate;
#endif

#if !defined(WASM32)
/**
 * Pointer to `CallClient`'s delegate object.
 */
typedef DailyRawCallClientDelegate *DailyCallClientDelegatePtr;
#endif

#if !defined(WASM32)
typedef void (*DailyCallClientOnEventFn)(DailyRawCallClientDelegate *delegate,
                                         const char *event_json,
                                         intptr_t json_len);
#endif

#if !defined(WASM32)
typedef struct DailyAudioData {
  uint32_t bits_per_sample;
  uint32_t sample_rate;
  uintptr_t num_channels;
  uintptr_t num_audio_frames;
  const uint8_t *audio_frames;
} DailyAudioData;
#endif

#if !defined(WASM32)
typedef void (*DailyCallClientOnAudioDataFn)(DailyRawCallClientDelegate *delegate,
                                             uint64_t renderer_id,
                                             const char *peer_id,
                                             const struct DailyAudioData *audio_data);
#endif

#if !defined(WASM32)
typedef struct DailyVideoFrame {
  const uint8_t *buffer;
  uintptr_t buffer_size;
  int32_t width;
  int32_t height;
  int64_t timestamp_us;
  const char *color_format;
} DailyVideoFrame;
#endif

#if !defined(WASM32)
typedef void (*DailyCallClientOnVideoFrameFn)(DailyRawCallClientDelegate *delegate,
                                              uint64_t renderer_id,
                                              const char *peer_id,
                                              const struct DailyVideoFrame *frame);
#endif

#if !defined(WASM32)
/**
 * Functions for integrating Daily with the given native platform.
 */
typedef struct DailyCallClientDelegateFns {
  DailyCallClientOnEventFn on_event;
  DailyCallClientOnAudioDataFn on_audio_data;
  DailyCallClientOnVideoFrameFn on_video_frame;
} DailyCallClientDelegateFns;
#endif

#if !defined(WASM32)
typedef struct DailyCallClientDelegate {
  /**
   * The functions' optional context (e.g. receiver).
   */
  DailyCallClientDelegatePtr ptr;
  /**
   * Functions for integrating with platform.
   */
  struct DailyCallClientDelegateFns fns;
} DailyCallClientDelegate;
#endif

#if !defined(WASM32)
typedef struct DailyCallClientLifecycleFns {
  struct DailyRawCallClient *(*create)(void);
  void (*destroy)(struct DailyRawCallClient *client);
  void (*set_delegate)(struct DailyRawCallClient *client, struct DailyCallClientDelegate delegate);
} DailyCallClientLifecycleFns;
#endif

#if !defined(WASM32)
typedef struct DailyCallClientLiveStreamFns {
  void (*start_live_stream)(struct DailyRawCallClient *client,
                            uint64_t request_id,
                            const char *properties);
  void (*stop_live_stream)(struct DailyRawCallClient *client,
                           uint64_t request_id,
                           const char *stream_id);
  void (*update_live_stream)(struct DailyRawCallClient *client,
                             uint64_t request_id,
                             const char *settings,
                             const char *stream_id);
  void (*add_live_streaming_endpoints)(struct DailyRawCallClient *client,
                                       uint64_t request_id,
                                       const char *endpoints,
                                       const char *stream_id);
  void (*remove_live_streaming_endpoints)(struct DailyRawCallClient *client,
                                          uint64_t request_id,
                                          const char *endpoints,
                                          const char *stream_id);
} DailyCallClientLiveStreamFns;
#endif

#if !defined(WASM32)
typedef struct DailyCallClientParticipantsFns {
  const char *(*participants)(struct DailyRawCallClient *client);
  const char *(*active_speaker)(struct DailyRawCallClient *client);
  const char *(*participant_counts)(struct DailyRawCallClient *client);
  void (*update_remote_participants)(struct DailyRawCallClient *client,
                                     uint64_t request_id,
                                     const char *updates_by_id);
  void (*eject_remote_participants)(struct DailyRawCallClient *client,
                                    uint64_t request_id,
                                    const char *ids);
} DailyCallClientParticipantsFns;
#endif

#if !defined(WASM32)
typedef struct DailyCallClientPublishingFns {
  const char *(*publishing)(struct DailyRawCallClient *client);
  void (*update_publishing)(struct DailyRawCallClient *client,
                            uint64_t request_id,
                            const char *publishing_settings);
} DailyCallClientPublishingFns;
#endif

#if !defined(WASM32)
typedef struct DailyCallClientRecordingFns {
  void (*start_recording)(struct DailyRawCallClient *client,
                          uint64_t request_id,
                          const char *properties);
  void (*stop_recording)(struct DailyRawCallClient *client,
                         uint64_t request_id,
                         const char *stream_id);
  void (*update_recording)(struct DailyRawCallClient *client,
                           uint64_t request_id,
                           const char *settings,
                           const char *stream_id);
} DailyCallClientRecordingFns;
#endif

#if !defined(WASM32)
typedef struct DailyCallClientSubscriptionsFns {
  const char *(*subscriptions)(struct DailyRawCallClient *client);
  void (*update_subscriptions)(struct DailyRawCallClient *client,
                               uint64_t request_id,
                               const char *participant_settings,
                               const char *profile_settings);
  const char *(*subscription_profiles)(struct DailyRawCallClient *client);
  void (*update_subscription_profiles)(struct DailyRawCallClient *client,
                                       uint64_t request_id,
                                       const char *profile_settings);
} DailyCallClientSubscriptionsFns;
#endif

#if !defined(WASM32)
typedef struct DailyCallClientTelemetryFns {
  const char *(*get_network_stats)(struct DailyRawCallClient *client);
} DailyCallClientTelemetryFns;
#endif

#if !defined(WASM32)
typedef struct DailyCallClientTranscriptionFns {
  void (*start_transcription)(struct DailyRawCallClient *client,
                              uint64_t request_id,
                              const char *properties);
  void (*stop_transcription)(struct DailyRawCallClient *client, uint64_t request_id);
} DailyCallClientTranscriptionFns;
#endif

#if !defined(WASM32)
typedef struct DailyCallClientUserFns {
  void (*set_user_name)(struct DailyRawCallClient *client,
                        uint64_t request_id,
                        const char *user_name);
  void (*update_permissions)(struct DailyRawCallClient *client,
                             uint64_t request_id,
                             const char *update);
} DailyCallClientUserFns;
#endif

#if !defined(WASM32)
typedef struct DailyCallClientFns {
  struct DailyCallClientAppMessageFns app_message;
  struct DailyCallClientAudioLevelFns audio_level;
  struct DailyCallClientCallStateFns call_state;
  struct DailyCallClientConnectionFns connection;
  struct DailyCallClientDevicesFns devices;
  struct DailyCallClientInputsFns inputs;
  struct DailyCallClientLifecycleFns lifecycle;
  struct DailyCallClientLiveStreamFns live_stream;
  struct DailyCallClientParticipantsFns participants;
  struct DailyCallClientPublishingFns publishing;
  struct DailyCallClientRecordingFns recording;
  struct DailyCallClientSubscriptionsFns subscriptions;
  struct DailyCallClientTelemetryFns telemetry;
  struct DailyCallClientTranscriptionFns transcription;
  struct DailyCallClientUserFns user;
} DailyCallClientFns;
#endif

#if !defined(WASM32)
typedef struct DailyCallClientDialoutFns {
  void (*start_dialout)(struct DailyRawCallClient *client,
                        uint64_t request_id,
                        const char *properties);
  void (*stop_dialout)(struct DailyRawCallClient *client,
                       uint64_t request_id,
                       const char *participant_id);
} DailyCallClientDialoutFns;
#endif

#if !defined(WASM32)
typedef struct DailyCallClientSipFns {
  void (*call_transfer)(struct DailyRawCallClient *client,
                        uint64_t request_id,
                        const char *properties);
  void (*refer)(struct DailyRawCallClient *client, uint64_t request_id, const char *properties);
} DailyCallClientSipFns;
#endif

#if !defined(WASM32)
typedef void WebrtcPeerConnectionFactory;
#endif

#if !defined(WASM32)
typedef void WebrtcThread;
#endif

#if !defined(WASM32)
typedef void DailyRawContextDelegate;
#endif

#if !defined(WASM32)
/**
 * Pointer to `Context`'s delegate object.
 */
typedef DailyRawContextDelegate *DailyContextDelegatePtr;
#endif

#if !defined(WASM32)
typedef struct DailyContextDelegate {
  /**
   * The functions' optional context (e.g. receiver).
   */
  DailyContextDelegatePtr ptr;
} DailyContextDelegate;
#endif

#if !defined(WASM32)
typedef void DailyRawWebRtcContextDelegate;
#endif

#if !defined(WASM32)
/**
 * Pointer to `DailyWebRtcContextDelegate` receiver object.
 */
typedef DailyRawWebRtcContextDelegate *DailyWebRtcContextDelegatePtr;
#endif

#if !defined(WASM32)
/**
 * Platform-provided implementation of `MediaDevices.getUserMedia()`.
 *
 * Arguments:
 * - `platform_ctx`: The functions' optional context (e.g. receiver).
 * - `peer_connection_factory`: Borrowed pointer to the peer connection factory (PCF).
 * - `signaling_thread`: Borrowed pointer to the PCF's signaling thread.
 * - `worker_thread`: Borrowed pointer to the PCF's worker thread.
 * - `constraints`: Borrowed pointer to JSON-encoded constraints.
 *
 * Returns a retained `webrtc::MediaStreamInterface*`, detached via `.release()`.
 */
typedef void *(*DailyWebRtcContextDelegateGetUserMediaFn)(DailyRawWebRtcContextDelegate *delegate,
                                                          WebrtcPeerConnectionFactory *peer_connection_factory,
                                                          WebrtcThread *signaling_thread,
                                                          WebrtcThread *worker_thread,
                                                          WebrtcThread *network_thread,
                                                          const char *constraints);
#endif

#if !defined(WASM32)
/**
 * Platform-provided implementation of `MediaDevices.getDisplayMedia()`.
 *
 * Arguments:
 * - `platform_ctx`: The functions' optional context (e.g. receiver).
 * - `peer_connection_factory`: Borrowed pointer to the peer connection factory (PCF).
 * - `signaling_thread`: Borrowed pointer to the PCF's signaling thread.
 * - `worker_thread`: Borrowed pointer to the PCF's worker thread.
 *
 * Returns a retained `webrtc::MediaStreamInterface*`, detached via `.release()`.
 */
typedef void *(*DailyWebRtcContextDelegateGetDisplayMediaFn)(DailyRawWebRtcContextDelegate *delegate,
                                                             WebrtcPeerConnectionFactory *peer_connection_factory,
                                                             WebrtcThread *signaling_thread,
                                                             WebrtcThread *worker_thread,
                                                             WebrtcThread *network_thread);
#endif

#if !defined(WASM32)
/**
 * Platform-provided implementation of `MediaDevices.enumerateDevices()`.
 *
 * Returns an owned JSON-encoded  list of media device infos.
 *
 * Media device info:
 * ```json
 * {
 *     deviceId: String,
 *     groupId: String,
 *     kind: "audioinput" | "audiooutput" | "videoinput",
 *     label: String
 * }
 * ```
 */
typedef char *(*DailyWebRtcContextDelegateGetEnumeratedDevicesFn)(DailyRawWebRtcContextDelegate *delegate);
#endif

#if !defined(WASM32)
typedef void WebrtcAudioDeviceModule;
#endif

#if !defined(WASM32)
typedef void WebrtcTaskQueueFactory;
#endif

#if !defined(WASM32)
typedef WebrtcAudioDeviceModule *(*DailyWebRtcContextDelegateCreateAudioDeviceModuleFn)(DailyRawWebRtcContextDelegate *delegate,
                                                                                        WebrtcTaskQueueFactory *task_queue_factory);
#endif

#if !defined(WASM32)
typedef void WebrtcVideoDecoderFactory;
#endif

#if !defined(WASM32)
typedef WebrtcVideoDecoderFactory *(*DailyWebRtcContextDelegateCreateVideoDecoderFactoryFn)(DailyRawWebRtcContextDelegate *delegate);
#endif

#if !defined(WASM32)
typedef void WebrtcVideoEncoderFactory;
#endif

#if !defined(WASM32)
typedef WebrtcVideoEncoderFactory *(*DailyWebRtcContextDelegateCreateVideoEncoderFactoryFn)(DailyRawWebRtcContextDelegate *delegate);
#endif

#if !defined(WASM32)
typedef void WebrtcAudioDecoderFactory;
#endif

#if !defined(WASM32)
typedef WebrtcAudioDecoderFactory *(*DailyWebRtcContextDelegateCreateAudioDecoderFactoryFn)(DailyRawWebRtcContextDelegate *delegate);
#endif

#if !defined(WASM32)
typedef void WebrtcAudioEncoderFactory;
#endif

#if !defined(WASM32)
typedef WebrtcAudioEncoderFactory *(*DailyWebRtcContextDelegateCreateAudioEncoderFactoryFn)(DailyRawWebRtcContextDelegate *delegate);
#endif

#if !defined(WASM32)
/**
 * Platform-provided implementation of `getAudioDevice`.
 */
typedef const char *(*DailyWebRtcContextDelegateGetAudioDeviceFn)(DailyRawWebRtcContextDelegate *delegate);
#endif

#if !defined(WASM32)
/**
 * Platform-provided implementation of `setAudioDevice`.
 */
typedef void (*DailyWebRtcContextDelegateSetAudioDeviceFn)(DailyRawWebRtcContextDelegate *delegate,
                                                           const char *deviceId);
#endif

#if !defined(WASM32)
typedef const char *(*DailyWebRtcContextDelegateGetIgnoredNetworkDevicesFn)(DailyRawWebRtcContextDelegate *delegate);
#endif

#if !defined(WASM32)
/**
 * Functions for integrating Daily with the given native platform.
 */
typedef struct DailyWebRtcContextDelegateFns {
  /**
   * Platform-provided implementation of `MediaDevices.getUserMedia()`.
   */
  DailyWebRtcContextDelegateGetUserMediaFn get_user_media;
  /**
   * Platform-provided implementation of `MediaDevices.getDisplayMedia()`.
   */
  DailyWebRtcContextDelegateGetDisplayMediaFn get_display_media;
  /**
   * Platform-provided implementation of `MediaDevices.enumerateDevices()`.
   */
  DailyWebRtcContextDelegateGetEnumeratedDevicesFn get_enumerated_devices;
  /**
   * Platform-provided function to create a new WebRTC AudioDeviceModule
   */
  DailyWebRtcContextDelegateCreateAudioDeviceModuleFn create_audio_device_module;
  /**
   * Platform-provided function to create a new WebRTC VideoDecoderFactory
   */
  DailyWebRtcContextDelegateCreateVideoDecoderFactoryFn create_video_decoder_factory;
  /**
   * Platform-provided function to create a new WebRTC VideoEncoderFactory
   */
  DailyWebRtcContextDelegateCreateVideoEncoderFactoryFn create_video_encoder_factory;
  /**
   * Platform-provided function to create a new WebRTC AudioDecoderFactory
   */
  DailyWebRtcContextDelegateCreateAudioDecoderFactoryFn create_audio_decoder_factory;
  /**
   * Platform-provided function to create a new WebRTC AudioEncoderFactory
   */
  DailyWebRtcContextDelegateCreateAudioEncoderFactoryFn create_audio_encoder_factory;
  /**
   * Platform-provided function to allow the mobile devices change the audio route
   */
  DailyWebRtcContextDelegateGetAudioDeviceFn get_audio_device;
  DailyWebRtcContextDelegateSetAudioDeviceFn set_audio_device;
  /**
   * Platform-provided function to request the list of ignored network interfaces, as a JSON array.
   */
  DailyWebRtcContextDelegateGetIgnoredNetworkDevicesFn get_ignored_network_devices;
} DailyWebRtcContextDelegateFns;
#endif

#if !defined(WASM32)
typedef struct DailyWebRtcContextDelegate {
  /**
   * The functions' optional context (e.g. receiver).
   */
  DailyWebRtcContextDelegatePtr ptr;
  /**
   * Functions for integrating with platform.
   */
  struct DailyWebRtcContextDelegateFns fns;
} DailyWebRtcContextDelegate;
#endif

#if !defined(WASM32)
/**
 * Information about the daily-x client library (e.g. daily-ios).
 */
typedef struct DailyAboutClient {
  /**
   * Library name, as a UTF-8 string
   */
  const char *library;
  /**
   * Library version in the "<major>.<minor>.<patch>" format, as a UTF-8 string
   */
  const char *version;
  /**
   * Operating system, as a UTF-8 string
   */
  const char *operating_system;
  /**
   * Operating system version, as a UTF-8 string
   */
  const char *operating_system_version;
  /**
   * App package name, as a UTF-8 string, or NULL
   */
  const char *app_package_name;
} DailyAboutClient;
#endif

#if !defined(WASM32)
typedef void DailyDeviceManager;
#endif

#if !defined(WASM32)
typedef void DailyAudioSource;
#endif

#if !defined(WASM32)
typedef void DailyRawAudioSenderDelegate;
#endif

#if !defined(WASM32)
typedef void (*DailyAudioSenderOnWriteFramesFn)(DailyRawAudioSenderDelegate *delegate,
                                                uint64_t request_id,
                                                uintptr_t num_frames);
#endif

#if !defined(WASM32)
typedef void DailyAudioTrack;
#endif

#if !defined(WASM32)
typedef void WebrtcMediaStream;
#endif

#if !defined(WASM32)
typedef void DailyVirtualCameraDevice;
#endif

#if !defined(WASM32)
typedef void DailyVirtualSpeakerDevice;
#endif

#if !defined(WASM32)
typedef void DailyVirtualMicrophoneDevice;
#endif

#if !defined(WASM32)
typedef void DailyRawVirtualSpeakerDeviceDelegate;
#endif

#if !defined(WASM32)
typedef void (*DailyVirtualSpeakerDeviceOnReadFramesFn)(DailyRawVirtualSpeakerDeviceDelegate *delegate,
                                                        uint64_t request_id,
                                                        int16_t *frames,
                                                        uintptr_t num_frames);
#endif

#if !defined(WASM32)
typedef void DailyVad;
#endif

#if !defined(WASM32)
typedef struct DailyCallClientInterface {
  /**
   * The functions' optional context (e.g. receiver).
   */
  struct DailyRawCallClient *ptr;
  /**
   * Functions for integrating with platform.
   */
  struct DailyCallClientFns fns;
} DailyCallClientInterface;
#endif

#if defined(WASM32)
extern EventEmitter new(void);
#endif

#if defined(WASM32)
extern JsValue add_event_listener(const EventEmitter *this_, const str *event, const Function *f);
#endif

#if defined(WASM32)
extern JsValue remove_event_listener(const EventEmitter *this_,
                                     const str *event,
                                     const Function *f);
#endif

#if defined(WASM32)
extern struct Result_bool__JsValue emit(const EventEmitter *this_, const str *event, JsValue data);
#endif

#if !defined(WASM32)
struct DailyCallClientFns daily_core_call_client_fns(void);
#endif

#if !defined(WASM32)
struct DailyCallClientAppMessageFns daily_core_call_client_app_message_fns(void);
#endif

#if !defined(WASM32)
/**
 * Send a custom app message
 */
void daily_core_call_client_send_app_message(struct DailyRawCallClient *client,
                                             uint64_t request_id,
                                             const char *message,
                                             const char *participant);
#endif

#if !defined(WASM32)
/**
 * Send a prebuilt chat message
 */
void daily_core_call_client_send_prebuilt_chat_message(struct DailyRawCallClient *client,
                                                       uint64_t request_id,
                                                       const char *message,
                                                       const char *name,
                                                       const char *room);
#endif

#if !defined(WASM32)
struct DailyCallClientAudioLevelFns daily_core_call_client_audio_level_fns(void);
#endif

#if !defined(WASM32)
void daily_core_call_client_start_remote_participants_audio_level_observer(struct DailyRawCallClient *client,
                                                                           uint64_t request_id,
                                                                           uint64_t interval);
#endif

#if !defined(WASM32)
void daily_core_call_client_stop_remote_participants_audio_level_observer(struct DailyRawCallClient *client,
                                                                          uint64_t request_id);
#endif

#if !defined(WASM32)
void daily_core_call_client_start_local_audio_level_observer(struct DailyRawCallClient *client,
                                                             uint64_t request_id,
                                                             uint64_t interval);
#endif

#if !defined(WASM32)
void daily_core_call_client_stop_local_audio_level_observer(struct DailyRawCallClient *client,
                                                            uint64_t request_id);
#endif

#if !defined(WASM32)
struct DailyCallClientCallStateFns daily_core_call_client_call_state_fns(void);
#endif

#if !defined(WASM32)
/**
 * Obtain the current call state
 */
enum DailyCallState daily_core_call_client_call_state(struct DailyRawCallClient *client);
#endif

#if !defined(WASM32)
/**
 * Retrieve the call config for a given URL and optional token
 */
void daily_core_call_client_call_config_for(struct DailyRawCallClient *client,
                                            uint64_t request_id,
                                            const char *url,
                                            const char *token);
#endif

#if !defined(WASM32)
struct DailyCallClientConnectionFns daily_core_call_client_connection_fns(void);
#endif

#if !defined(WASM32)
/**
 * Connects to a call with the given URL and client settings.
 * This function can fail if the URL or settings are not valid, and
 * blocks until the call is joined, or is failed to be joined.
 * If this call fails (due to invalid settings, or other reasons), it
 * will return a null pointer.
 * # Safety
 * Calling this function with a null URL parameter will result in a crash.
 */
void daily_core_call_client_join(struct DailyRawCallClient *client,
                                 uint64_t request_id,
                                 const char *url,
                                 const char *token,
                                 const char *client_settings);
#endif

#if !defined(WASM32)
/**
 * Leave the current Daily call
 * # Safety
 * Will result in a crash if called prior to a [daily_core_context_create] or after [daily_core_context_destroy]
 */
void daily_core_call_client_leave(struct DailyRawCallClient *client,
                                  uint64_t request_id);
#endif

#if !defined(WASM32)
/**
 * For users whose firewall policies prevent them from directly accessing
 * Daily’s web domains, using a proxy url provide a mechanism to send connections
 * to Daily's HTTPS and WebSocket endpoints to a specified proxy server instead.
 */
void daily_core_call_client_set_proxy_url(struct DailyRawCallClient *client,
                                          uint64_t request_id,
                                          const char *proxy_url);
#endif

#if !defined(WASM32)
/**
 * Allows for specifying custom TURN servers rather than only using Daily's default TURN servers.
 */
void daily_core_call_client_set_ice_config(struct DailyRawCallClient *client,
                                           uint64_t request_id,
                                           const char *ice_config);
#endif

#if !defined(WASM32)
struct DailyCallClientDevicesFns daily_core_call_client_devices_fns(void);
#endif

#if !defined(WASM32)
/**
 * Obtain the media devices available to the call client
 * # Safety
 * Will crash if called prior to a [daily_core_context_create] or after [daily_core_context_destroy]
 */
const char *daily_core_call_client_available_devices(struct DailyRawCallClient *client,
                                                     const char *config);
#endif

#if !defined(WASM32)
void daily_core_call_client_trigger_devices_changed(struct DailyRawCallClient *client);
#endif

#if !defined(WASM32)
struct DailyCallClientDialoutFns daily_core_call_client_dialout_fns(void);
#endif

#if !defined(WASM32)
/**
 * Start a dial-out to SIP or PSTN.
 */
void daily_core_call_client_start_dialout(struct DailyRawCallClient *client,
                                          uint64_t request_id,
                                          const char *properties);
#endif

#if !defined(WASM32)
/**
 * Stop an existing dial-out session.
 */
void daily_core_call_client_stop_dialout(struct DailyRawCallClient *client,
                                         uint64_t request_id,
                                         const char *participant_id);
#endif

#if !defined(WASM32)
/**
 * Send DTMF tones in a dial-out session.
 */
void daily_core_call_client_send_dtmf(struct DailyRawCallClient *client,
                                      uint64_t request_id,
                                      const char *properties);
#endif

#if !defined(WASM32)
struct DailyCallClientInputsFns daily_core_call_client_inputs_fns(void);
#endif

#if !defined(WASM32)
/**
 * Obtain the currently desired input settings
 * # Safety
 * Will crash if the `query_config` parameter is not a valid pointer
 * to a `const char *` (or `nullptr`)
 */
const char *daily_core_call_client_inputs(struct DailyRawCallClient *client);
#endif

#if !defined(WASM32)
/**
 * Update the desired input settings for this call
 * # Safety
 * Will crash if the `input_settings` parameter is not a valid pointer
 * to a `const char *`.
 */
void daily_core_call_client_update_inputs(struct DailyRawCallClient *client,
                                          uint64_t request_id,
                                          const char *input_settings);
#endif

#if !defined(WASM32)
/**
 * Adds a custom video track
 * # Safety
 * Will crash if the `name` parameter is not a valid pointer to a `const char
 * *` or if `track_ptr` is not a valid pointer to a video media track.
 */
void daily_core_call_client_add_custom_video_track(struct DailyRawCallClient *client,
                                                   uint64_t request_id,
                                                   const char *name,
                                                   const void *track_ptr);
#endif

#if !defined(WASM32)
/**
 * Updates a custom video track
 * # Safety
 * Will crash if the `name` parameter is not a valid pointer to a `const char
 * *` or if `track_ptr` is not a valid pointer to a video media track.
 */
void daily_core_call_client_update_custom_video_track(struct DailyRawCallClient *client,
                                                      uint64_t request_id,
                                                      const char *name,
                                                      const void *track_ptr);
#endif

#if !defined(WASM32)
/**
 * Removes a custom video track
 * # Safety
 * Will crash if the `name` parameter is not a valid pointer to a `const char
 * *`.
 */
void daily_core_call_client_remove_custom_video_track(struct DailyRawCallClient *client,
                                                      uint64_t request_id,
                                                      const char *name);
#endif

#if !defined(WASM32)
/**
 * Adds a custom audio track
 * # Safety
 * Will crash if the `name` parameter is not a valid pointer to a `const char
 * *` or if `track_ptr` is not a valid pointer to a audio media track.
 */
void daily_core_call_client_add_custom_audio_track(struct DailyRawCallClient *client,
                                                   uint64_t request_id,
                                                   const char *name,
                                                   const void *track_ptr);
#endif

#if !defined(WASM32)
/**
 * Updates a custom audio track
 * # Safety
 * Will crash if the `name` parameter is not a valid pointer to a `const char
 * *` or if `track_ptr` is not a valid pointer to a audio media track.
 */
void daily_core_call_client_update_custom_audio_track(struct DailyRawCallClient *client,
                                                      uint64_t request_id,
                                                      const char *name,
                                                      const void *track_ptr);
#endif

#if !defined(WASM32)
/**
 * Removes a custom audio track
 * # Safety
 * Will crash if the `name` parameter is not a valid pointer to a `const char
 * *`.
 */
void daily_core_call_client_remove_custom_audio_track(struct DailyRawCallClient *client,
                                                      uint64_t request_id,
                                                      const char *name);
#endif

#if !defined(WASM32)
struct DailyCallClientLifecycleFns daily_core_call_client_lifecycle_fns(void);
#endif

#if !defined(WASM32)
/**
 * Create a new instance of a Daily call client.
 * # Safety
 * Invoking this call prior to [daily_core_context_create] or after [daily_core_context_destroy] will result in a crash
 */
struct DailyRawCallClient *daily_core_call_client_create(void);
#endif

#if !defined(WASM32)
/**
 * Teardown a Daily call client instance.
 * # Safety
 * This call will crash if the provided parameter is not a valid pointer to a
 * previously constructed `DailyCallClient`
 */
void daily_core_call_client_destroy(struct DailyRawCallClient *client);
#endif

#if !defined(WASM32)
/**
 * Register an [EventListener] to receive all events from Daily Core.
 * If another event listener has been set previously, it will be replaced.
 * # Safety
 * This call may crash if the callback or the previously set native context are not valid
 */
void daily_core_call_client_set_delegate(struct DailyRawCallClient *client,
                                         struct DailyCallClientDelegate delegate);
#endif

#if !defined(WASM32)
struct DailyCallClientLiveStreamFns daily_core_call_client_live_stream_fns(void);
#endif

#if !defined(WASM32)
/**
 * Start a live stream
 */
void daily_core_call_client_start_live_stream(struct DailyRawCallClient *client,
                                              uint64_t request_id,
                                              const char *properties);
#endif

#if !defined(WASM32)
/**
 * Stop a live stream
 */
void daily_core_call_client_stop_live_stream(struct DailyRawCallClient *client,
                                             uint64_t request_id,
                                             const char *stream_id);
#endif

#if !defined(WASM32)
/**
 * Update a live stream
 */
void daily_core_call_client_update_live_stream(struct DailyRawCallClient *client,
                                               uint64_t request_id,
                                               const char *settings,
                                               const char *stream_id);
#endif

#if !defined(WASM32)
/**
 * Add a new endpoints for a live stream
 */
void daily_core_call_client_add_live_streaming_endpoints(struct DailyRawCallClient *client,
                                                         uint64_t request_id,
                                                         const char *endpoints,
                                                         const char *stream_id);
#endif

#if !defined(WASM32)
/**
 * Remove endpoints from a live stream
 */
void daily_core_call_client_remove_live_streaming_endpoints(struct DailyRawCallClient *client,
                                                            uint64_t request_id,
                                                            const char *endpoints,
                                                            const char *stream_id);
#endif

#if !defined(WASM32)
struct DailyCallClientParticipantsFns daily_core_call_client_participants_fns(void);
#endif

#if !defined(WASM32)
/**
 * Obtain the current participants in the call
 */
const char *daily_core_call_client_participants(struct DailyRawCallClient *client);
#endif

#if !defined(WASM32)
/**
 * Obtain the current active speaker in the call
 */
const char *daily_core_call_client_active_speaker(struct DailyRawCallClient *client);
#endif

#if !defined(WASM32)
const char *daily_core_call_client_participant_counts(struct DailyRawCallClient *client);
#endif

#if !defined(WASM32)
/**
 * Modify things about remote participants that you can control as a meeting
 * owner.
 */
void daily_core_call_client_update_remote_participants(struct DailyRawCallClient *client,
                                                       uint64_t request_id,
                                                       const char *updates_by_id);
#endif

#if !defined(WASM32)
/**
 * Eject remote participants.
 */
void daily_core_call_client_eject_remote_participants(struct DailyRawCallClient *client,
                                                      uint64_t request_id,
                                                      const char *ids);
#endif

#if !defined(WASM32)
/**
 * Register an audio renderer to receive participant audio data for the given
 * audio source (microphone, screenAudio, ...) from Daily Core. If another
 * renderer ID has been previously set for the same participant, the new
 * renderer ID will be used.
 * # Safety
 * This might result in a crash if there is no `on_audio_data` delegate.
 */
void daily_core_call_client_set_participant_audio_renderer(struct DailyRawCallClient *client,
                                                           uint64_t request_id,
                                                           uint64_t renderer_id,
                                                           const char *participant_id,
                                                           const char *audio_source);
#endif

#if !defined(WASM32)
/**
 * Register a video renderer to receive participant frames for the given video
 * source (camera, screenVideo, ...) from Daily Core. If another renderer ID
 * has been previously set for the same participant, the new renderer ID will
 * be used.
 * # Safety
 * This might result in a crash if there is no `on_video_frame` delegate.
 */
void daily_core_call_client_set_participant_video_renderer(struct DailyRawCallClient *client,
                                                           uint64_t request_id,
                                                           uint64_t renderer_id,
                                                           const char *participant_id,
                                                           const char *video_source,
                                                           const char *color_format);
#endif

#if !defined(WASM32)
struct DailyCallClientPublishingFns daily_core_call_client_publishing_fns(void);
#endif

#if !defined(WASM32)
/**
 * Obtain the current publishing settings for this call
 * # Safety
 * Will crash if the `query_config` parameter is not a valid pointer
 * to a `const char *` (or `nullptr`)
 */
const char *daily_core_call_client_publishing(struct DailyRawCallClient *client);
#endif

#if !defined(WASM32)
/**
 * Update the desired publishing settings for this call
 * # Safety
 * Will crash if the `publishing_settings` parameter is
 * not a valid pointer to `const char *`
 */
void daily_core_call_client_update_publishing(struct DailyRawCallClient *client,
                                              uint64_t request_id,
                                              const char *publishing_settings);
#endif

#if !defined(WASM32)
struct DailyCallClientRecordingFns daily_core_call_client_recording_fns(void);
#endif

#if !defined(WASM32)
/**
 * Start a recording
 */
void daily_core_call_client_start_recording(struct DailyRawCallClient *client,
                                            uint64_t request_id,
                                            const char *properties);
#endif

#if !defined(WASM32)
/**
 * Stop a recording
 */
void daily_core_call_client_stop_recording(struct DailyRawCallClient *client,
                                           uint64_t request_id,
                                           const char *stream_id);
#endif

#if !defined(WASM32)
/**
 * Update a recording
 */
void daily_core_call_client_update_recording(struct DailyRawCallClient *client,
                                             uint64_t request_id,
                                             const char *settings,
                                             const char *stream_id);
#endif

#if !defined(WASM32)
struct DailyCallClientSipFns daily_core_call_client_sip_call_transfer_fns(void);
#endif

#if !defined(WASM32)
/**
 * Transfer a SIP dial-in call from one Daily room to another Daily
 * room. Alternatively, transfer an initiated SIP/PSTN Dialout to another SIP
 * URI or PSTN number.
 */
void daily_core_call_client_sip_call_transfer(struct DailyRawCallClient *client,
                                              uint64_t request_id,
                                              const char *properties);
#endif

#if !defined(WASM32)
/**
 * Transfer a SIP dial-in call to another SIP endpoint outside Daily.
 */
void daily_core_call_client_sip_refer(struct DailyRawCallClient *client,
                                      uint64_t request_id,
                                      const char *properties);
#endif

#if !defined(WASM32)
struct DailyCallClientSubscriptionsFns daily_core_call_client_subscriptions_fns(void);
#endif

#if !defined(WASM32)
/**
 * Obtain the current subscription settings
 */
const char *daily_core_call_client_subscriptions(struct DailyRawCallClient *client);
#endif

#if !defined(WASM32)
/**
 * Update the desired subscription settings for this call
 * # Safety
 * Will crash if the `participant_settings` or `profile_settings` parameters
 * are not valid pointers to `const char *`
 */
void daily_core_call_client_update_subscriptions(struct DailyRawCallClient *client,
                                                 uint64_t request_id,
                                                 const char *participant_settings,
                                                 const char *profile_settings);
#endif

#if !defined(WASM32)
/**
 * Obtain the current subscription profiles
 */
const char *daily_core_call_client_subscription_profiles(struct DailyRawCallClient *client);
#endif

#if !defined(WASM32)
/**
 * Update the current subscription profiles
 * # Safety
 * This call will crash if `profile_settings` is not a valid pointer to a non-null
 * const char* containing the profiles as JSON
 */
void daily_core_call_client_update_subscription_profiles(struct DailyRawCallClient *client,
                                                         uint64_t request_id,
                                                         const char *profile_settings);
#endif

#if !defined(WASM32)
struct DailyCallClientTelemetryFns daily_core_call_client_telemetry_fns(void);
#endif

#if !defined(WASM32)
const char *daily_core_call_client_get_network_stats(struct DailyRawCallClient *client);
#endif

#if !defined(WASM32)
struct DailyCallClientTranscriptionFns daily_core_call_client_transcription_fns(void);
#endif

#if !defined(WASM32)
/**
 * Start a transcription
 */
void daily_core_call_client_start_transcription(struct DailyRawCallClient *client,
                                                uint64_t request_id,
                                                const char *properties);
#endif

#if !defined(WASM32)
/**
 * Stop a transcription
 */
void daily_core_call_client_stop_transcription(struct DailyRawCallClient *client,
                                               uint64_t request_id);
#endif

#if !defined(WASM32)
/**
 * Update a transcription
 */
void daily_core_call_client_update_transcription(struct DailyRawCallClient *client,
                                                 uint64_t request_id,
                                                 const char *participants,
                                                 const char *instance_id);
#endif

#if !defined(WASM32)
struct DailyCallClientUserFns daily_core_call_client_user_fns(void);
#endif

#if !defined(WASM32)
/**
 * Set the username
 */
void daily_core_call_client_set_user_name(struct DailyRawCallClient *client,
                                          uint64_t request_id,
                                          const char *user_name);
#endif

#if !defined(WASM32)
/**
 * Modify your own permissions
 */
void daily_core_call_client_update_permissions(struct DailyRawCallClient *client,
                                               uint64_t request_id,
                                               const char *update);
#endif

#if !defined(WASM32)
/**
 * Returns a borrowed pointer to the WebRTC `PeerConnectionFactory`.
 */
WebrtcPeerConnectionFactory *daily_core_context_peer_connection_factory(void);
#endif

#if !defined(WASM32)
/**
 * Returns a borrowed pointer to the WebRTC network thread.
 */
WebrtcThread *daily_core_context_network_thread(void);
#endif

#if !defined(WASM32)
/**
 * Returns a borrowed pointer to the WebRTC worker thread.
 */
WebrtcThread *daily_core_context_worker_thread(void);
#endif

#if !defined(WASM32)
/**
 * Returns a borrowed pointer to the WebRTC signaling thread.
 */
WebrtcThread *daily_core_context_signaling_thread(void);
#endif

#if !defined(WASM32)
/**
 * Returns a borrowed pointer to the WebRTC `PeerConnectionFactory`.
 */
void *daily_core_context_track_retained(const char *id_ptr);
#endif

#if !defined(WASM32)
void daily_core_context_track_release(void *ptr);
#endif

#if !defined(WASM32)
/**
 * Creates a backing execution context.
 *
 * A backing execution context must exist before any FFI other `daily_core_…()`
 * functions may be called.
 *
 * Note however that only ONE backing context MUST exist at a time.
 * As such any additional call of this function must be preceded
 * by a corresponding call of [daily_core_context_destroy].
 *
 * The user of Daily is responsible for invoking
 * [daily_core_context_destroy] to correctly clean up on application
 * termination and/or after the last call-client has been destroyed (if desirable).
 */
void daily_core_context_create(struct DailyContextDelegate delegate,
                               struct DailyWebRtcContextDelegate webrtc_delegate,
                               struct DailyAboutClient about_client);
#endif

#if !defined(WASM32)
/**
 * This function is identical to [daily_core_context_create], but allows
 * for customizing the number of worker threads available to the execution
 * context.
 */
void daily_core_context_create_with_threads(struct DailyContextDelegate delegate,
                                            struct DailyWebRtcContextDelegate webrtc_delegate,
                                            struct DailyAboutClient about_client,
                                            uintptr_t worker_threads);
#endif

#if !defined(WASM32)
/**
 * Destroys the backing execution context created via [daily_core_context_create].
 *
 * The user of Daily is responsible for invoking this function on application
 * termination and/or after the last call-client has been destroyed (if desirable).
 */
void daily_core_context_destroy(void);
#endif

#if !defined(WASM32)
/**
 * Creates a device manager. The device manager can handle system and virtual
 * devices. New virtual devices can be added with
 * [daily_core_context_create_virtual_camera_device],
 * [daily_core_context_create_virtual_microphone_device] or
 * [daily_core_context_create_virtual_speaker_device].
 */
DailyDeviceManager *daily_core_context_create_device_manager(void);
#endif

#if !defined(WASM32)
/**
 * Creates a custom audio source, which makes it possible to send audio frames.
 */
DailyAudioSource *daily_core_context_create_custom_audio_source(void);
#endif

#if !defined(WASM32)
/**
 * Writes audio frames to a custom audio source created with
 * [daily_core_context_create_custom_audio_source]. This function is
 * non-blocking.
 */
void daily_core_context_custom_audio_source_write_frames(DailyAudioSource *daily_audio_source,
                                                         const void *audio_data,
                                                         int32_t bits_per_sample,
                                                         int32_t sample_rate,
                                                         uintptr_t number_of_channels,
                                                         uintptr_t num_frames);
#endif

#if !defined(WASM32)
/**
 * Writes audio frames to a custom audio source created with
 * [daily_core_context_create_custom_audio_source]. This function blocks until
 * the audio frames have been written.
 */
int32_t daily_core_context_custom_audio_source_write_frames_sync(DailyAudioSource *daily_audio_source,
                                                                 const void *audio_data,
                                                                 int32_t bits_per_sample,
                                                                 int32_t sample_rate,
                                                                 uintptr_t number_of_channels,
                                                                 uintptr_t num_frames);
#endif

#if !defined(WASM32)
/**
 * Writes audio frames to a custom audio source created with
 * [daily_core_context_create_custom_audio_source]. This function is
 * non-blocking and the provided `callback` will be called when the audio
 * frames have been written.
 */
int32_t daily_core_context_custom_audio_source_write_frames_async(DailyAudioSource *daily_audio_source,
                                                                  const void *audio_data,
                                                                  int32_t bits_per_sample,
                                                                  int32_t sample_rate,
                                                                  uintptr_t number_of_channels,
                                                                  uintptr_t num_frames,
                                                                  uint64_t request_id,
                                                                  DailyAudioSenderOnWriteFramesFn callback,
                                                                  DailyRawAudioSenderDelegate *callback_target);
#endif

#if !defined(WASM32)
/**
 * Creates a custom audio track. Custom audio tracks need a custom audio source
 * to write audio frames. Custom audio sources can be created with
 * [daily_core_context_create_custom_audio_source].
 */
const DailyAudioTrack *daily_core_context_create_custom_audio_track(DailyAudioSource *audio_source);
#endif

#if !defined(WASM32)
/**
 * Creates a virtual audio device module. New virtual audio devices
 * (microphones and speakers) can then be added.
 *
 * This audio device module can be created through the
 * `create_audio_device_module` callback passed to
 * [daily_core_context_create].
 */
WebrtcAudioDeviceModule *daily_core_context_create_audio_device_module(DailyDeviceManager *device_manager,
                                                                       WebrtcTaskQueueFactory *task_queue_factory);
#endif

#if !defined(WASM32)
/**
 * Implements enumeratedDevices for a previously created device manager.
 */
char *daily_core_context_device_manager_enumerated_devices(const DailyDeviceManager *device_manager);
#endif

#if !defined(WASM32)
/**
 * Implements getUserMedia for a previously created device manager. It is meant
 * to be used for system and virtual devices. For example, a new virtual
 * microphone device can be created via
 * [daily_core_context_create_microphone_device] with a given device name. That
 * device name can then be used as a `deviceId` in the microphone settings when
 * specifying the inputs.
 */
WebrtcMediaStream *daily_core_context_device_manager_get_user_media(DailyDeviceManager *device_manager,
                                                                    WebrtcPeerConnectionFactory *peer_connection_factory,
                                                                    WebrtcThread *signaling_thread,
                                                                    WebrtcThread *worker_thread,
                                                                    WebrtcThread *network_thread,
                                                                    const char *constraints);
#endif

#if !defined(WASM32)
/**
 * Creates a virtual camera device. This virtual camera device can be used to
 * send video frames to the meeting. The resolution (width and height) and
 * color format of the camera need to be specified to know what type of frames
 * are then written with
 * [daily_core_context_virtual_camera_device_write_frame]. For example,
 * internally frames are converted to I420 so the color format is used to know
 * what type of conversion needs to be applied.
 */
DailyVirtualCameraDevice *daily_core_context_create_virtual_camera_device(DailyDeviceManager *device_manager,
                                                                          const char *device_name,
                                                                          uint32_t width,
                                                                          uint32_t height,
                                                                          const char *color_format);
#endif

#if !defined(WASM32)
/**
 * Writes a video frame to a virtual camera device created with
 * [daily_core_context_create_virtual_camera_device]. The video frame
 * resolution (width and height) and color format needs to match the one
 * specified by the camema.
 */
void daily_core_context_virtual_camera_device_write_frame(DailyVirtualCameraDevice *device,
                                                          const uint8_t *frame,
                                                          uintptr_t size);
#endif

#if !defined(WASM32)
/**
 * Creates a virtual speaker device. This device will only be created if an
 * audio device module has been previously created with
 * [daily_core_context_create_audio_device_module].
 *
 * A virtual speaker device can be used to receive audio samples from the
 * meeting.
 */
DailyVirtualSpeakerDevice *daily_core_context_create_virtual_speaker_device(DailyDeviceManager *device_manager,
                                                                            const char *device_name,
                                                                            uint32_t sample_rate,
                                                                            uint8_t channels,
                                                                            bool non_blocking);
#endif

#if !defined(WASM32)
/**
 * Creates a virtual microphone device. This device will only be created if an
 * audio device module has been previously created with
 * [daily_core_context_create_audio_device_module].
 *
 * A virtual microphone device can be used to send audio samples to the
 * meeting.
 */
DailyVirtualMicrophoneDevice *daily_core_context_create_virtual_microphone_device(DailyDeviceManager *device_manager,
                                                                                  const char *device_name,
                                                                                  uint32_t sample_rate,
                                                                                  uint8_t channels,
                                                                                  bool non_blocking);
#endif

#if !defined(WASM32)
/**
 * Selects the given speaker device as the system's active speaker device. This
 * can be a system or a virtual speaker. Returns true if the device was
 * selected properly, false otherwise.
 */
bool daily_core_context_select_speaker_device(DailyDeviceManager *device_manager,
                                              const char *device_name);
#endif

#if !defined(WASM32)
/**
 * Returns the current selected speaker device or NULL if no device is selected
 * yet.
 */
DailyVirtualSpeakerDevice *daily_core_context_get_selected_speaker_device(const DailyDeviceManager *device_manager);
#endif

#if !defined(WASM32)
/**
 * Returns the current selected microphone device or NULL if no device is
 * selected yet.
 */
DailyVirtualMicrophoneDevice *daily_core_context_get_selected_microphone_device(const DailyDeviceManager *device_manager);
#endif

#if !defined(WASM32)
/**
 * Read audio frames from a virtual speaker device created with
 * [daily_core_context_create_virtual_speaker_device]. Returns the number of
 * audio frames read.
 */
int32_t daily_core_context_virtual_speaker_device_read_frames(DailyVirtualSpeakerDevice *device,
                                                              int16_t *frames,
                                                              uintptr_t num_frames,
                                                              uint64_t request_id,
                                                              DailyVirtualSpeakerDeviceOnReadFramesFn callback,
                                                              DailyRawVirtualSpeakerDeviceDelegate *callback_target);
#endif

#if !defined(WASM32)
/**
 * Writes audio frames to a virtual microphone device created with
 * [daily_core_context_create_virtual_microphone_device]. Returns the number of
 * audio frames written.
 */
int32_t daily_core_context_virtual_microphone_device_write_frames(DailyVirtualMicrophoneDevice *device,
                                                                  const int16_t *frames,
                                                                  uintptr_t num_frames,
                                                                  uint64_t request_id,
                                                                  DailyAudioSenderOnWriteFramesFn callback,
                                                                  DailyRawAudioSenderDelegate *callback_target);
#endif

#if !defined(WASM32)
/**
 * Creates a native VAD analyzer. VADs are used to detect speech.
 */
DailyVad *daily_core_context_create_vad(uint32_t reset_period_ms,
                                        uint32_t sample_rate,
                                        uint8_t channels);
#endif

#if !defined(WASM32)
/**
 * Use VAD to analyze 10ms of audio frames. If more than 10ms of audio frames
 * are given, only the first 10ms will be used.
 */
float daily_core_context_vad_analyze(DailyVad *vad, const int16_t *frames, uintptr_t num_frames);
#endif

#if !defined(WASM32)
/**
 * Set the WebRTC, mediasoupclient, and daily log levels.
 */
void daily_core_set_log_level(enum DailyLogLevel log_level);
#endif
